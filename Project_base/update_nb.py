import json
import os

notebook_path = '/home/taamangtchu/Documents/Github/Comparative-study-of-the-Anderson-model-in-weak-and-strong-interaction-regimes/Project_base/notebooks_roadmap/01_core_methodologies/process_tensor_decomposition.ipynb'

with open(notebook_path, 'r') as f:
    nb = json.load(f)

# Step 3 is usually in cell index 6-7 (approx)
# Let's find the cell containing "def compute_pade_coefficients"
for cell in nb['cells']:
    if cell['cell_type'] == 'code' and 'def compute_pade_coefficients' in cell['source'][0]:
        cell['source'] = [
            "def compute_pade_coefficients(beta, lambda_reorg, omega_c, nterms=10):\n",
            "    \"\"\"\n",
            "    Compute Padé coefficients for Drude-Lorentz spectral density.\n",
            "    \n",
            "    Parameters:\n",
            "    -----------\n",
            "    beta : float\n",
            "        Inverse temperature β = 1/(k_B*T)\n",
            "    lambda_reorg : float\n",
            "        Reorganization energy\n",
            "    omega_c : float\n",
            "        Cutoff frequency\n",
            "    nterms : int\n",
            "        Number of Padé terms\n",
            "        \n",
            "    Returns:\n",
            "    --------\n",
            "    poles : array\n",
            "        Padé poles ν_k\n",
            "    residues : array\n",
            "        Padé residues c_k\n",
            "    \"\"\"\n",
            "    # Rigorous Padé decomposition for Bose-Einstein/Fermi-Dirac distribution\n",
            "    # We use the [N, N] Padé approximant for the Fermi function\n",
            "    \n",
            "    # Define the matrix A and B for the eigenvalue problem (Hu et al., JCP 2011)\n",
            "    M = 2 * nterms\n",
            "    A = np.zeros((M, M))\n",
            "    for i in range(1, M):\n",
            "        A[i-1, i] = 1.0 / np.sqrt((2*i-1)*(2*i+1))\n",
            "    A = A + A.T\n",
            "    \n",
            "    eigvals = np.linalg.eigvalsh(A)\n",
            "    nu_k = 2.0 / eigvals[eigvals > 0]\n",
            "    \n",
            "    # For Drude-Lorentz, we have the pole at i*omega_c\n",
            "    # and the Matsubara poles approximated by Padé\n",
            "    all_poles = np.zeros(nterms + 1)\n",
            "    all_residues = np.zeros(nterms + 1, dtype=complex)\n",
            "    \n",
            "    all_poles[0] = omega_c\n",
            "    all_residues[0] = lambda_reorg * omega_c * (1.0 / (np.exp(beta * omega_c) + 1.0))\n",
            "    \n",
            "    for k in range(nterms):\n",
            "        # Rescale Padé poles back to energy units\n",
            "        all_poles[k+1] = nu_k[k] / beta \n",
            "        # Residue = J(i*nu_k) * (2/beta)\n",
            "        # Use the complex extension of J(omega)\n",
            "        z_k = 1j * all_poles[k+1]\n",
            "        all_residues[k+1] = (2 * lambda_reorg * omega_c * z_k / (z_k**2 + omega_c**2)) * (2.0 / beta)\n",
            "        \n",
            "    return all_poles, all_residues\n",
            "\n",
            "# Calculate Padé coefficients\n",
            "pade_poles, pade_residues = compute_pade_coefficients(beta, lambda_reorg, omega_c, nterms=8)\n",
            "\n",
            "# Print results\n",
            "print(f'Padé decomposition with {len(pade_poles)} terms:')\n",
            "print('Poles (ω_k, cm⁻¹):')\n",
            "for i, pole in enumerate(pade_poles):\n",
            "    print(f'  k={i}: {pole:.2f}')\n",
            "\n",
            "print(\"\\nResidues (c_k, cm⁻¹):\")\n",
            "for i, residue in enumerate(pade_residues):\n",
            "    print(f'  k={i}: {residue.real:.2f} + {residue.imag:.2f}j')\n",
            "\n",
            "# Reconstruct correlation function using Padé approximation\n",
            "def pade_correlation(t, poles, residues):\n",
            "    \"\"\"Reconstruct correlation function using Padé approximation\"\"\"\n",
            "    # Conversion factor from cm^-1 to fs^-1\n",
            "    # 1 cm^-1 = 2*pi*c*100 s^-1 = 2*pi*2.9979e10 s^-1 = 0.000188 ffs^-1\n",
            "    conv = 2 * np.pi * 2.9979e-5 \n",
            "    \n",
            "    t_fs = np.array(t)\n",
            "    if np.isscalar(t_fs):\n",
            "        t_fs = np.array([t_fs])\n",
            "    \n",
            "    result = np.zeros_like(t_fs, dtype=complex)\n",
            "    for c_k, nu_k in zip(residues, poles):\n",
            "        result += c_k * np.exp(-nu_k * t_fs * conv)\n",
            "    \n",
            "    return result if not np.isscalar(t) else result[0]\n",
            "\n",
            "# Compare original and Padé approximated correlation functions\n",
            "C_pade = pade_correlation(t_range, pade_poles, pade_residues)\n",
            "\n",
            "plt.figure(figsize=(12, 5))\n",
            "plt.subplot(1, 2, 1)\n",
            "plt.plot(t_range, C_real, 'b-', linewidth=2, label='Original (Numerical)')\n",
            "plt.plot(t_range, np.real(C_pade), 'r--', linewidth=2, label='Padé Approximation')\n",
            "plt.xlabel('Time (fs)')\n",
            "plt.ylabel('Re[C(t)]')\n",
            "plt.title('Real part comparison')\n",
            "plt.grid(True, alpha=0.3)\n",
            "plt.legend()\n",
            "\n",
            "plt.subplot(1, 2, 2)\n",
            "plt.plot(t_range, C_imag, 'b-', linewidth=2, label='Original (Numerical)')\n",
            "plt.plot(t_range, np.imag(C_pade), 'r--', linewidth=2, label='Padé Approximation')\n",
            "plt.xlabel('Time (fs)')\n",
            "plt.ylabel('Im[C(t)]')\n",
            "plt.title('Imaginary part comparison')\n",
            "plt.grid(True, alpha=0.3)\n",
            "plt.legend()\n",
            "\n",
            "plt.tight_layout()\n",
            "plt.show()\n"
        ]

with open(notebook_path, 'w') as f:
    json.dump(nb, f, indent=1)

print('Notebook updated successfully.')
